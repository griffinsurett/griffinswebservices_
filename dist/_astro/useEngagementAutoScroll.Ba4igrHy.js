import{r as s}from"./react-core.lhpfgRL0.js";import{r as F,u as N,a as q}from"./useVisibility.Cx5WauJp.js";const V=({elementRef:a,tapThreshold:p=10,longPressDelay:y=500,swipeThreshold:x=50,preventDefaultOnTouch:g=!1,onTouchStart:M=()=>{},onTouchEnd:C=()=>{},onTouchMove:E=()=>{},onTap:L=()=>{},onLongPress:w=()=>{},onSwipe:h=()=>{}}={})=>{const n=s.useRef({active:!1,startX:0,startY:0,startTime:0,moved:!1,longPressTriggered:!1}),u=s.useRef(null),i=s.useCallback(()=>{u.current&&(clearTimeout(u.current),u.current=null)},[]),v=s.useCallback(()=>{n.current={active:!1,startX:0,startY:0,startTime:0,moved:!1,longPressTriggered:!1},i()},[i]),m=s.useCallback((l,d)=>{const f=l-n.current.startX,T=d-n.current.startY,e=Math.hypot(f,T),t=Date.now()-n.current.startTime;let c=null;return Math.abs(f)>Math.abs(T)?c=f>0?"right":"left":c=T>0?"down":"up",{deltaX:f,deltaY:T,distance:e,duration:t,direction:c}},[]);return s.useEffect(()=>{const l=F(a);if(!l)return;const d=t=>{const c=t.touches[0];c&&(n.current={active:!0,startX:c.clientX,startY:c.clientY,startTime:Date.now(),moved:!1,longPressTriggered:!1},g&&t.preventDefault(),M(t,{x:c.clientX,y:c.clientY,timestamp:n.current.startTime}),u.current=setTimeout(()=>{n.current.active&&!n.current.moved&&(n.current.longPressTriggered=!0,w(t,{x:n.current.startX,y:n.current.startY,duration:Date.now()-n.current.startTime}))},y))},f=t=>{const c=t.touches[0];if(!c||!n.current.active)return;const R=c.clientX-n.current.startX,r=c.clientY-n.current.startY,o=Math.hypot(R,r);!n.current.moved&&o>p&&(n.current.moved=!0,i()),g&&t.preventDefault(),E(t,{x:c.clientX,y:c.clientY,deltaX:R,deltaY:r,distance:o,moved:n.current.moved})},T=t=>{const c=t.changedTouches[0];if(!c)return;g&&t.preventDefault();const R=Date.now()-n.current.startTime,r={x:c.clientX,y:c.clientY,duration:R,moved:n.current.moved,longPressTriggered:n.current.longPressTriggered};if(C(t,r),!n.current.moved&&!n.current.longPressTriggered&&L(t,r),n.current.moved){const o=m(c.clientX,c.clientY);o.distance>=x&&h(t,{...r,...o})}v()},e=t=>{C(t,{x:n.current.startX,y:n.current.startY,duration:Date.now()-n.current.startTime,moved:n.current.moved,longPressTriggered:n.current.longPressTriggered}),v()};return l.addEventListener("touchstart",d,{passive:!g}),l.addEventListener("touchmove",f,{passive:!g}),l.addEventListener("touchend",T,{passive:!g}),l.addEventListener("touchcancel",e,{passive:!0}),()=>{l.removeEventListener("touchstart",d),l.removeEventListener("touchmove",f),l.removeEventListener("touchend",T),l.removeEventListener("touchcancel",e),i()}},[a,p,y,x,g,M,C,E,L,w,h,m,v,i]),s.useEffect(()=>()=>i(),[i]),{isTouchActive:()=>n.current.active,getTouchState:()=>({...n.current}),resetTouchState:v}},_=({elementRef:a,pointerTypes:p=["mouse","touch","pen"],clickThreshold:y=10,longPressDelay:x=500,preventDefaultOnPointer:g=!1,onPointerDown:M=()=>{},onPointerUp:C=()=>{},onPointerMove:E=()=>{},onPointerCancel:L=()=>{},onPointerClick:w=()=>{},onPointerLongPress:h=()=>{}}={})=>{const n=s.useRef(new Map),u=s.useRef(new Map),i=s.useCallback(m=>{const l=u.current.get(m);l&&(clearTimeout(l),u.current.delete(m))},[]),v=s.useCallback(()=>{u.current.forEach(m=>clearTimeout(m)),u.current.clear()},[]);return s.useEffect(()=>{const m=F(a);if(!m)return;const l=e=>{if(!p.includes(e.pointerType))return;const t=e.pointerId,c={startX:e.clientX,startY:e.clientY,startTime:Date.now(),moved:!1,pointerType:e.pointerType};n.current.set(t,c),g&&e.preventDefault(),M(e,{pointerId:t,x:e.clientX,y:e.clientY,pointerType:e.pointerType,timestamp:c.startTime});const R=setTimeout(()=>{const r=n.current.get(t);r&&!r.moved&&h(e,{pointerId:t,x:r.startX,y:r.startY,pointerType:r.pointerType,duration:Date.now()-r.startTime})},x);u.current.set(t,R)},d=e=>{if(!p.includes(e.pointerType))return;const t=e.pointerId,c=n.current.get(t);if(!c)return;const R=e.clientX-c.startX,r=e.clientY-c.startY,o=Math.hypot(R,r);!c.moved&&o>y&&(c.moved=!0,i(t)),g&&e.preventDefault(),E(e,{pointerId:t,x:e.clientX,y:e.clientY,pointerType:e.pointerType,deltaX:R,deltaY:r,distance:o,moved:c.moved})},f=e=>{if(!p.includes(e.pointerType))return;const t=e.pointerId,c=n.current.get(t);if(!c)return;const R=Date.now()-c.startTime;i(t),g&&e.preventDefault();const r={pointerId:t,x:e.clientX,y:e.clientY,pointerType:e.pointerType,duration:R,moved:c.moved};C(e,r),c.moved||w(e,r),n.current.delete(t)},T=e=>{if(!p.includes(e.pointerType))return;const t=e.pointerId;i(t),L(e,{pointerId:t,x:e.clientX,y:e.clientY,pointerType:e.pointerType}),n.current.delete(t)};return m.addEventListener("pointerdown",l,{passive:!g}),m.addEventListener("pointermove",d,{passive:!g}),m.addEventListener("pointerup",f,{passive:!g}),m.addEventListener("pointercancel",T,{passive:!0}),()=>{m.removeEventListener("pointerdown",l),m.removeEventListener("pointermove",d),m.removeEventListener("pointerup",f),m.removeEventListener("pointercancel",T),v()}},[a,p,y,x,g,M,E,C,L,w,h,i,v]),s.useEffect(()=>()=>v(),[v]),{getActivePointers:()=>Array.from(n.current.keys()),getPointerState:m=>n.current.get(m),clearAllTimers:v}};function D({ref:a,active:p=!1,speed:y=40,cycleDuration:x=0,loop:g=!1,startDelay:M=1500,resetOnInactive:C=!0}){const E=s.useRef(null),L=s.useRef(0),w=s.useRef(null),h=s.useRef(0),n=s.useRef(!1),u=s.useRef(!1),i=s.useRef(null),[v,m]=s.useState(0),l=s.useCallback(r=>{if(x&&x>0){const o=Math.max(0,r.scrollHeight-r.clientHeight);return o>0?o/x:0}return typeof y=="function"?Math.max(1,y(r)):Number(y)||0},[x,y]),d=s.useCallback(()=>{E.current&&cancelAnimationFrame(E.current),E.current=null,L.current=0},[]),f=s.useCallback(()=>{w.current&&(clearTimeout(w.current),w.current=null)},[]),T=s.useCallback(()=>{u.current=!0,i.current&&(cancelAnimationFrame(i.current),i.current=null),i.current=requestAnimationFrame(()=>{u.current=!1,i.current=null})},[]),e=s.useCallback(r=>{if(!p)return;const o=a.current;if(!o)return;const S=L.current||r,Y=Math.min(.05,Math.max(0,(r-S)/1e3));L.current=r;const b=Math.max(0,o.scrollHeight-o.clientHeight);if(b<=0){E.current=requestAnimationFrame(e);return}h.current===0&&o.scrollTop>0&&(h.current=o.scrollTop);const A=l(o)*Y;if(h.current=Math.min(b,h.current+A),T(),o.scrollTo({top:h.current,left:0,behavior:"auto"}),h.current>=b-.5)if(g)h.current=0,o.scrollTo({top:0,left:0,behavior:"auto"});else{d();return}E.current=requestAnimationFrame(e)},[p,d,g,T,a,l]),t=s.useCallback(()=>{d();const r=a.current;r&&(h.current=r.scrollTop||0,n.current=!0,E.current=requestAnimationFrame(e))},[d,a,e]),c=s.useCallback(()=>{d()},[d]),R=s.useCallback((r=0)=>{const o=a.current;o&&(h.current=r,o.scrollTo({top:r,left:0,behavior:"auto"}))},[a]);return s.useEffect(()=>(d(),f(),p&&(n.current?t():w.current=setTimeout(()=>{p&&t()},Math.max(0,M))),()=>{d(),f()}),[p,M,t,d,f,v]),s.useEffect(()=>{C&&(p||(n.current=!1,d(),f(),u.current=!1,h.current=0,a.current?.scrollTo({top:0,left:0,behavior:"auto"})))},[p,d,f,a,C]),s.useEffect(()=>{const r=a.current;if(!r||typeof ResizeObserver>"u")return;let o=Math.max(0,r.scrollHeight-r.clientHeight);const S=new ResizeObserver(()=>{const Y=Math.max(0,r.scrollHeight-r.clientHeight);Y>o+1&&(o=Y,m(b=>b+1))});return S.observe(r),()=>S.disconnect()},[a]),s.useEffect(()=>()=>{d(),f(),i.current&&(cancelAnimationFrame(i.current),i.current=null),u.current=!1},[d,f]),{startNow:t,stopNow:c,resetPosition:R,isAnimating:()=>!!E.current,hasStartedThisCycle:()=>n.current,getCurrentPosition:()=>h.current,internalScrollRef:u,getMetrics:()=>{const r=a.current,o=r?Math.max(0,r.scrollHeight-r.clientHeight):0,S=r?r.scrollTop:0,Y=o>0?S/o:0;return{top:S,max:o,progress:Y,animating:!!E.current,started:n.current,internalGuard:u.current}}}}function z({ref:a,active:p=!1,speed:y=40,cycleDuration:x=0,loop:g=!1,startDelay:M=1500,resumeDelay:C=900,resumeOnUserInput:E=!0,threshold:L=.3,visibleRootMargin:w="0px",resetOnInactive:h=!0}){const n=s.useRef(null),u=s.useRef(!1),[i,v]=s.useState(!1),[m,l]=s.useState(!1),[d,f]=s.useState(!1),T=N(a,{threshold:L,rootMargin:w}),e=D({ref:a,active:p&&T&&!i,speed:y,cycleDuration:x,loop:g,startDelay:M,resetOnInactive:h}),t=s.useCallback(()=>{n.current&&(clearTimeout(n.current),n.current=null),l(!1)},[]),c=s.useCallback(()=>{v(!0),t()},[t]),R=s.useCallback(()=>{E&&(u.current||(t(),l(!0),n.current=setTimeout(()=>{u.current||(l(!1),v(!1))},Math.max(0,C))))},[E,C,t]),r=s.useCallback(b=>{const X=a.current;X&&X.dispatchEvent(new CustomEvent("autoscroll-user",{bubbles:!0,detail:{phase:b}}))},[a]),o=s.useCallback(()=>{u.current=!0,f(!0),c(),r("start")},[c,r]),S=s.useCallback(()=>{u.current=!1,f(!1),r("end"),R()},[r,R]),Y=s.useCallback(()=>{u.current=!0,f(!0)},[]);return V({elementRef:a,tapThreshold:8,longPressDelay:600,onTouchStart:o,onTouchMove:(b,X)=>{X.moved&&o()},onTouchEnd:S,onLongPress:o,preventDefaultOnTouch:!1}),q({elementRef:a,scrollThreshold:1,debounceDelay:80,trustedOnly:!0,internalFlagRef:e.internalScrollRef,wheelSensitivity:1,onScrollStart:o,onScrollActivity:Y,onWheelActivity:o,onScrollEnd:S}),_({elementRef:a,onPointerDown:o,onPointerMove:(b,X)=>{X.moved&&o()},onPointerUp:S}),s.useEffect(()=>{const b=a.current;if(!b)return;const X=160,A=160;let P=null,k=null;const I=()=>{e.internalScrollRef.current||(o(),P&&clearTimeout(P),P=setTimeout(S,X))},H=()=>{o(),k&&clearTimeout(k),k=setTimeout(S,A)};return b.addEventListener("scroll",I,{passive:!0}),b.addEventListener("wheel",H,{passive:!0}),()=>{b.removeEventListener("scroll",I),b.removeEventListener("wheel",H),P&&clearTimeout(P),k&&clearTimeout(k)}},[e.internalScrollRef,S,o,a]),s.useEffect(()=>{h&&(!p||!T)&&(u.current=!1,f(!1),v(!1),t())},[p,T,h,t]),s.useEffect(()=>()=>{t(),u.current=!1,f(!1)},[t]),{inView:T,paused:i,resumeScheduled:m,engaged:d,pauseNow:c,resumeNow:()=>{t(),v(!1)},startNow:e.startNow,stopNow:e.stopNow,resetPosition:e.resetPosition,isAnimating:e.isAnimating,hasStartedThisCycle:e.hasStartedThisCycle,getCurrentPosition:e.getCurrentPosition,getMetrics:e.getMetrics}}export{z as u};
