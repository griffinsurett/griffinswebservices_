---
// src/components/ContentRenderer/variants/FilteredPortfolioVariant.astro
/**
 * Filtered Portfolio Variant
 *
 * Collection-neutral filtered carousel that:
 * - Uses one collection as filter tabs (e.g., industries)
 * - Fetches items from another collection that reference the current filter
 * - 3D carousel transitions between filters
 * - Image cycling within each filter group
 *
 * @example
 * // Industries as filters, projects fetched per industry
 * <ContentRenderer
 *   query={query('industries')}
 *   variant="FilteredPortfolioVariant"
 *   relatedCollection="projects"
 *   relatedField="industry"
 *   filter={{ showCount: true }}
 * />
 */

import { getImage } from "astro:assets";
import { getCollection } from "astro:content";
import type { CollectionKey } from "astro:content";
import type { BaseVariantProps } from "../ContentRenderer.types";
import type { FilterConfig } from "@/hooks/useFilter";
import SectionHeader from "@/components/SectionHeader.astro";
import Section from "@/components/Section.astro";
import Button from "@/components/Button/Button";
import FilteredPortfolioCarousel from "@/components/LoopTemplates/Portfolio/FilteredPortfolioCarousel";
import { shouldShowCollectionCTA } from "../utils/helpers";
import { getImageAlt, resolveImageMetadata } from "@/utils/images";
import { toArray } from "@/utils/array";

interface Props extends BaseVariantProps {
  /** Filter configuration */
  filter?: FilterConfig;
  /** Filter tab size */
  filterSize?: "sm" | "md" | "lg";
  /** Additional class for filter tabs */
  filterClassName?: string;
  /** Show filter tabs */
  showFilters?: boolean;
  /** Show navigation arrows */
  showArrows?: boolean;
  /** Enable drag navigation */
  drag?: boolean;
  /** Custom CTA href */
  ctaHref?: string;
  /** Custom CTA text */
  ctaText?: string;
  /** Collection to fetch related items from (e.g., "projects") */
  relatedCollection?: CollectionKey;
  /** Field on related items that references the filter items (e.g., "industry") */
  relatedField?: string;
}

const {
  items = [],
  title,
  heading: headingValue,
  description,
  className = "",
  collectionUrl,
  collectionTitle,
  id,
  showButtonSection = true,
  ctaHref,
  ctaText,
  filter,
  filterSize = "sm",
  filterClassName = "",
  showFilters = true,
  showArrows = true,
  drag = false,
  relatedCollection = "projects",
  relatedField = "industry",
} = Astro.props as Props;

// Items are the filter tabs (e.g., industries)
const filterItems = toArray(items) as Record<string, any>[];

// Fetch the related collection (e.g., projects)
const relatedItems = await getCollection(relatedCollection);

// Image optimization settings
const IMAGE_WIDTHS = [480, 640, 860, 1024, 1280, 1600];
const SIZES = "(max-width: 640px) 90vw, (max-width: 1024px) 70vw, 860px";
const IMAGE_FORMATS: { format: "avif" | "webp"; quality: number }[] = [
  { format: "avif", quality: 45 },
  { format: "webp", quality: 65 },
];
const FALLBACK_FORMAT = "webp";

// Helper to check if a related item references a filter item
function matchesFilter(relatedItem: Record<string, any>, filterKey: string): boolean {
  const fieldValue = relatedItem.data?.[relatedField] ?? relatedItem[relatedField];
  if (!fieldValue) return false;

  if (typeof fieldValue === "string") {
    return fieldValue === filterKey;
  }
  if (typeof fieldValue === "object" && fieldValue !== null) {
    return fieldValue.id === filterKey || fieldValue.slug === filterKey;
  }
  return false;
}

// Helper to optimize a single item's image
async function optimizeItemImage(item: Record<string, any>) {
  const primaryImage =
    (typeof item.image === "object" ? item.image : undefined) ??
    item.featuredImage ??
    item.bannerImage;

  const metadata = resolveImageMetadata(primaryImage);
  const altText = primaryImage
    ? getImageAlt(primaryImage, item.title ?? "Project preview")
    : (item.title ?? "Project preview");

  if (!metadata) {
    return { data: { ...item, alt: altText }, mediaEntry: undefined };
  }

  const optimizedByFormat = await Promise.all(
    IMAGE_FORMATS.map(async ({ format, quality }) => {
      const images = await Promise.all(
        IMAGE_WIDTHS.map((width) =>
          getImage({ src: metadata, width, format, quality })
        )
      );
      return { format, images };
    })
  );

  const fallbackFormatEntry =
    optimizedByFormat.find((e) => e.format === FALLBACK_FORMAT) ??
    optimizedByFormat[optimizedByFormat.length - 1];

  if (!fallbackFormatEntry?.images.length) {
    return { data: { ...item, alt: altText }, mediaEntry: undefined };
  }

  const fallbackImages = fallbackFormatEntry.images;
  const fallbackSrcSet = fallbackImages
    .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
    .join(", ");
  const defaultImage = fallbackImages[fallbackImages.length - 1];

  const pictureSources = optimizedByFormat
    .filter((e) => e.format !== FALLBACK_FORMAT)
    .map((entry) => ({
      type: `image/${entry.format}`,
      srcSet: entry.images
        .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
        .join(", "),
      sizes: SIZES,
    }));

  return {
    data: { ...item, alt: altText },
    mediaEntry: {
      src: defaultImage.src,
      srcSet: fallbackSrcSet,
      sizes: SIZES,
      width: defaultImage.attributes.width as number,
      height: defaultImage.attributes.height as number,
      alt: altText,
      sources: pictureSources,
    },
  };
}

// Build groups: each filter item with its related items
const groups = await Promise.all(
  filterItems.map(async (filterItem) => {
    const filterKey = filterItem.id ?? filterItem.slug;

    // Find related items that reference this filter
    const matchingItems = relatedItems.filter((item) => matchesFilter(item, filterKey));

    // Sort by order field
    matchingItems.sort((a, b) => (a.data.order ?? 999) - (b.data.order ?? 999));

    // Optimize images for each matching item
    const processedItems = await Promise.all(
      matchingItems.map(async (item) => {
        const itemData = { ...item.data, id: item.id, slug: item.id };
        return optimizeItemImage(itemData);
      })
    );

    return {
      key: filterKey,
      label: filterItem.title ?? filterItem.data?.title ?? filterKey,
      icon: filterItem.icon ?? filterItem.data?.icon,
      order: filterItem.order ?? filterItem.data?.order ?? 999,
      items: processedItems.map((p) => p.data),
      mediaEntries: processedItems.map((p) => p.mediaEntry),
      count: processedItems.length,
    };
  })
);

// Filter out groups with no items and sort by order
const validGroups = groups
  .filter((group) => group.count > 0)
  .sort((a, b) => a.order - b.order);

const totalItems = validGroups.reduce((sum, g) => sum + g.count, 0);
const sectionTitle = collectionTitle ?? title;
const showHeader = Boolean(sectionTitle || headingValue || description);
---

<Section
  id={id}
  class={`outer-section relative overflow-hidden ${className}`.trim()}
>
  <div class="">
    {showHeader && (
      <SectionHeader
        title={sectionTitle}
        heading={headingValue}
        description={description}
        className="text-center inner-section"
        headingClassName="h2 mb-6 heading-padding"
        descriptionClassName="large-text max-w-2xl mx-auto"
      />
    )}

    {validGroups.length > 0 && (
      <FilteredPortfolioCarousel
        client:visible
        groups={validGroups}
        filter={filter}
        filterSize={filterSize}
        filterClassName={filterClassName}
        showFilters={showFilters}
        showArrows={showArrows}
        drag={drag}
        className={showHeader ? "mt-12" : ""}
      />
    )}

    {showButtonSection &&
      shouldShowCollectionCTA(collectionUrl, totalItems) &&
      (ctaText || title || collectionTitle) &&
      (ctaHref || collectionUrl) && (
      <div class="buttons-section-center">
        <Button
          client:visible
          href={ctaHref ?? collectionUrl}
          rightIcon="lu:arrow-right"
          variant="secondary"
        >
          {ctaText ?? `View All ${(title ?? collectionTitle ?? "").trim()}`}
        </Button>
      </div>
    )}
  </div>
</Section>
