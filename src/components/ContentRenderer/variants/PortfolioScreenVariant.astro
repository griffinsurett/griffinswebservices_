---
// PortfolioScreenVariant.astro
// Below-the-fold portfolio showcase - hydrates only when visible
import { getImage } from "astro:assets";
import type { BaseVariantProps } from "../ContentRenderer.types";
import PortfolioScreenShowcase from "@/components/LoopTemplates/PortfolioScreenShowcase";
import { getImageAlt, resolveImageMetadata } from "@/utils/images";
import { toArray } from "@/utils/array";

interface Props extends BaseVariantProps {}

const {
  items = [],
  className = "",
  id,
} = Astro.props as Props;

const safeItems = toArray(items);

if (!safeItems.length) {
  return;
}

// Target widths for responsive images - container is max-w-4xl (896px)
const IMAGE_WIDTHS = [320, 480, 520, 640, 860];
const SIZES = "(max-width: 640px) calc(100vw - 48px), (max-width: 1024px) min(calc(100vw - 48px), 896px), 896px";
// Clamp extremely tall screenshots
const MAX_RENDER_HEIGHT = 3600;

type OptimizedFormat = "avif" | "webp";
const FALLBACK_FORMAT: OptimizedFormat = "webp";
const IMAGE_FORMATS: { format: OptimizedFormat; quality: number }[] = [
  { format: "avif", quality: 45 },
  { format: "webp", quality: 65 },
];

// Process items and generate optimized images
const processedItems = await Promise.all(
  safeItems.map(async (item) => {
    const primaryImage = item.featuredImage ?? item.bannerImage;
    const metadata = resolveImageMetadata(primaryImage);
    const altText = primaryImage
      ? getImageAlt(primaryImage, item.title ?? "Project preview")
      : item.title ?? "Project preview";

    if (!metadata) {
      return { data: item, mediaEntry: undefined };
    }

    // Generate optimized images for each format + width combo
    const optimizedByFormat = await Promise.all(
      IMAGE_FORMATS.map(async ({ format, quality }) => {
        const images = await Promise.all(
          IMAGE_WIDTHS.map((width) => {
            const aspectRatio = metadata.height / metadata.width;
            const naturalHeight = Math.round(aspectRatio * width);
            const constrainedHeight = Math.min(naturalHeight, MAX_RENDER_HEIGHT);
            const shouldConstrain = constrainedHeight < naturalHeight;
            const resizeOptions = shouldConstrain
              ? {
                  height: constrainedHeight,
                  fit: "cover" as const,
                  position: "top" as const,
                }
              : {};

            return getImage({
              src: metadata,
              width,
              format,
              quality,
              ...resizeOptions,
            });
          })
        );
        return { format, images };
      })
    );

    const fallbackFormatEntry =
      optimizedByFormat.find((entry) => entry.format === FALLBACK_FORMAT) ??
      optimizedByFormat[optimizedByFormat.length - 1];

    if (!fallbackFormatEntry) {
      return { data: item, mediaEntry: undefined };
    }

    const fallbackImages = fallbackFormatEntry.images;
    if (!fallbackImages.length) {
      return { data: item, mediaEntry: undefined };
    }

    const fallbackSrcSet = fallbackImages
      .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
      .join(", ");
    const defaultImage = fallbackImages[fallbackImages.length - 1];

    const pictureSources = optimizedByFormat
      .filter((entry) => entry.format !== FALLBACK_FORMAT)
      .map((entry) => ({
        type: `image/${entry.format}`,
        srcSet: entry.images
          .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
          .join(", "),
        sizes: SIZES,
      }));

    return {
      data: item,
      mediaEntry: {
        src: defaultImage.src,
        srcSet: fallbackSrcSet,
        sizes: SIZES,
        width: defaultImage.attributes.width as number,
        height: defaultImage.attributes.height as number,
        alt: altText,
        loading: "lazy" as const,
        decoding: "async" as const,
        fetchPriority: "auto" as const,
        sources: pictureSources,
      },
    };
  })
);

const portfolioItems = processedItems.map((entry) => entry.data);
const showcaseMedia = processedItems.map((entry) => entry.mediaEntry);

const showcaseProps = {
  items: portfolioItems,
  mediaEntries: showcaseMedia,
  className: "w-full mx-auto",
};
---

<section
  id={id}
  class={`relative overflow-hidden p-6 ${className}`.trim()}
>
  <div class="relative w-full max-w-4xl mx-auto h-[420px] sm:h-[500px]">
    <div class="relative h-full">
      <PortfolioScreenShowcase client:visible {...showcaseProps} />
    </div>
  </div>
</section>
