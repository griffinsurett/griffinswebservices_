---
// PortfolioScreenVariant.astro
import { getImage } from "astro:assets";
import type { BaseVariantProps } from "../ContentRenderer.types";
import PortfolioScreenShowcase from "@/components/LoopTemplates/PortfolioScreenShowcase";
import { getImageAlt, resolveImageMetadata, generateCroppedPreview } from "@/utils/images";
import { toArray } from "@/utils/array";

interface Props extends BaseVariantProps {}

const {
  items = [],
  className = "",
  id,
} = Astro.props as Props;

const safeItems = toArray(items);

if (!safeItems.length) {
  return;
}

// Target widths for responsive images - max display is ~860px in the showcase
const IMAGE_WIDTHS = [320, 480, 640, 860];
const SIZES = "(max-width: 640px) 100vw, (max-width: 1024px) 80vw, 860px";
// Clamp extremely tall scrolling screenshots so the downloaded file
// isn't much larger than the visible area in the showcase.
const MAX_RENDER_HEIGHT = 3600;
type OptimizedFormat = "avif" | "webp";
const FALLBACK_FORMAT: OptimizedFormat = "webp";
const IMAGE_FORMATS: { format: OptimizedFormat; quality: number }[] = [
  // AVIF first for maximum compression, with a slightly lower quality target
  { format: "avif", quality: 45 },
  // WebP fallback keeps quality high enough for crisp UI details
  { format: "webp", quality: 65 },
];

// Cropped preview dimensions - must match visible area exactly
// Container: h-[420px] sm:h-[500px], header bar is ~48px
// Figure visible height: mobile ~372px, desktop ~452px
// We generate at the desktop height since it covers both cases
// Width matches container max-w-4xl (896px) but we use common breakpoints
const PREVIEW_HEIGHT = 452;
const PREVIEW_WIDTHS = [320, 480, 640, 896];

// Process items and generate optimized images
const processedItems = await Promise.all(
  safeItems.map(async (item, index) => {
    const primaryImage =
      item.featuredImage ??
      item.bannerImage;

    const metadata = resolveImageMetadata(primaryImage);
    const altText = primaryImage
      ? getImageAlt(primaryImage, item.title ?? "Project preview")
      : item.title ?? "Project preview";

    // First image should be eager loaded for LCP optimization
    const isFirst = index === 0;

    if (!metadata) {
      return { data: item, mediaEntry: undefined, croppedPreview: undefined };
    }

    // Generate optimized images for each requested format + width combo
    const optimizedByFormat = await Promise.all(
      IMAGE_FORMATS.map(async ({ format, quality }) => {
        const images = await Promise.all(
          IMAGE_WIDTHS.map((width) => {
            const aspectRatio = metadata.height / metadata.width;
            const naturalHeight = Math.round(aspectRatio * width);
            const constrainedHeight = Math.min(naturalHeight, MAX_RENDER_HEIGHT);
            const shouldConstrain = constrainedHeight < naturalHeight;
            const resizeOptions = shouldConstrain
              ? {
                  height: constrainedHeight,
                  fit: "cover" as const,
                  position: "top" as const,
                }
              : {};

            return getImage({
              src: metadata,
              width,
              format,
              quality,
              ...resizeOptions,
            });
          })
        );

        return { format, images };
      })
    );

    const fallbackFormatEntry =
      optimizedByFormat.find((entry) => entry.format === FALLBACK_FORMAT) ??
      optimizedByFormat[optimizedByFormat.length - 1];

    if (!fallbackFormatEntry) {
      return { data: item, mediaEntry: undefined, croppedPreview: undefined };
    }

    const fallbackImages = fallbackFormatEntry.images;
    if (!fallbackImages.length) {
      return { data: item, mediaEntry: undefined, croppedPreview: undefined };
    }

    const fallbackSrcSet = fallbackImages
      .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
      .join(", ");
    const defaultImage = fallbackImages[fallbackImages.length - 1];

    const pictureSources = optimizedByFormat
      .filter((entry) => entry.format !== FALLBACK_FORMAT)
      .map((entry) => ({
        type: `image/${entry.format}`,
        srcSet: entry.images
          .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
          .join(", "),
        sizes: SIZES,
      }));

    // For the first item, generate a cropped "above the fold" preview
    // This is a small image showing just the top portion - fast to load
    let croppedPreview = undefined;
    if (isFirst) {
      // Generate multiple widths for each format
      const previewConfigs: { width: number; height: number; format: "avif" | "webp"; quality: number }[] = [];
      for (const width of PREVIEW_WIDTHS) {
        previewConfigs.push({ width, height: PREVIEW_HEIGHT, format: "avif", quality: 55 });
        previewConfigs.push({ width, height: PREVIEW_HEIGHT, format: "webp", quality: 75 });
      }

      const previewResults = await generateCroppedPreview(metadata, previewConfigs);

      const avifResults = previewResults.filter(r => r.config.format === "avif");
      const webpResults = previewResults.filter(r => r.config.format === "webp");

      const webpSrcSet = webpResults
        .map(r => `${r.image.src} ${r.config.width}w`)
        .join(", ");
      const avifSrcSet = avifResults
        .map(r => `${r.image.src} ${r.config.width}w`)
        .join(", ");

      const defaultWebp = webpResults[webpResults.length - 1];

      croppedPreview = {
        src: defaultWebp?.image.src ?? previewResults[0]?.image.src,
        srcSet: webpSrcSet,
        sizes: SIZES,
        width: 896,
        height: PREVIEW_HEIGHT,
        alt: altText,
        sources: avifSrcSet ? [{
          type: "image/avif",
          srcSet: avifSrcSet,
          sizes: SIZES,
        }] : [],
      };
    }

    return {
      data: item,
      mediaEntry: {
        src: defaultImage.src,
        srcSet: fallbackSrcSet,
        sizes: SIZES,
        width: defaultImage.attributes.width as number,
        height: defaultImage.attributes.height as number,
        alt: altText,
        loading: "lazy" as const,
        decoding: "async" as const,
        fetchPriority: "auto" as const,
        sources: pictureSources,
        // No desktopEager - cropped preview handles initial load,
        // React carousel always lazy-loads full images
      },
      croppedPreview,
    };
  })
);

const portfolioItems = processedItems.map((entry) => entry.data);
const showcaseMedia = processedItems.map((entry) => entry.mediaEntry);

// Extract first item's cropped preview for static rendering
const firstPreview = processedItems[0]?.croppedPreview;
const firstItem = portfolioItems[0];
---

<section
  id={id}
  class={`relative overflow-hidden p-6 ${className}`.trim()}
>
  <div class="relative w-full mx-auto">
    {/* Static first slide - visible until JS hydrates */}
    <div
      id="portfolio-static-first"
      class="relative mx-auto w-full max-w-4xl overflow-hidden rounded-lg h-[420px] sm:h-[500px]"
    >
      <div class="relative h-full w-full">
        <div class="relative h-full bg-bg3">
          <div class="flex flex-col gap-3 border-b border-white/10 px-4 py-3 text-white/70 sm:flex-row sm:items-center sm:justify-between">
            <div class="flex items-center gap-3 text-xs uppercase tracking-[0.35em] text-white/50">
              <span class="flex items-center gap-1.5">
                <span class="h-3 w-3 rounded-full bg-gray-800"></span>
                <span class="h-3 w-3 rounded-full bg-gray-800"></span>
                <span class="h-3 w-3 rounded-full bg-gray-800"></span>
              </span>
            </div>
          </div>
          <figure class="relative h-full overflow-hidden bg-black/40">
            {/* Cropped "above the fold" preview - exact fit, no scroll needed */}
            {/* Simple width fill - image is pre-cropped to visible area */}
            {firstPreview?.src ? (
              <picture>
                {firstPreview.sources?.map((source) => (
                  <source
                    srcset={source.srcSet}
                    sizes={source.sizes}
                    type={source.type}
                  />
                ))}
                <img
                  src={firstPreview.src}
                  srcset={firstPreview.srcSet}
                  sizes={firstPreview.sizes}
                  alt={firstPreview.alt || firstItem?.title || "Project preview"}
                  width={firstPreview.width}
                  height={firstPreview.height}
                  loading="eager"
                  decoding="async"
                  fetchpriority="high"
                  draggable="false"
                  class="block w-full select-none"
                />
              </picture>
            ) : null}
          </figure>
        </div>
      </div>
    </div>

    {/* React carousel - hidden until hydrated, loads when browser idle */}
    <div id="portfolio-carousel-container" class="hidden">
      <PortfolioScreenShowcase
        client:idle
        items={portfolioItems}
        mediaEntries={showcaseMedia}
        className="w-full mx-auto"
        staticContainerId="portfolio-static-first"
        carouselContainerId="portfolio-carousel-container"
      />
    </div>
  </div>
</section>
