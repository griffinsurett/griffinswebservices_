---
// src/components/Section.astro
/**
 * Flexible Section Component
 *
 * A simple wrapper component that defaults to <section> but can be changed
 * to any HTML element via the `tag` prop.
 *
 * Supports scroll-triggered animations via:
 * - animate: Animation type (e.g., "fade-in-up", "fade-in", "scale-in")
 * - animateOnce: Whether animation plays only once (default: true for JS, N/A for CSS)
 * - animateRange: CSS animation range preset ("delayed", "cover", "cover-fast", "contain", "exit")
 * - animateCss: Use pure CSS animation-timeline instead of JS IntersectionObserver
 */

type AnimationType =
  | "fade-in"
  | "fade-in-up"
  | "fade-in-down"
  | "fade-in-left"
  | "fade-in-right"
  | "fade-in-scale"
  | "scale-in"
  | "pop-in"
  | "zoom-in"
  | "slide-up"
  | "slide-down"
  | "slide-left"
  | "slide-right"
  | "scroll-zoom"
  | "scroll-zoom-in"
  | "scroll-zoom-out"
  | "scroll-pulse";

type AnimateRange = "delayed" | "cover" | "cover-fast" | "contain" | "exit";

export interface Props {
  tag?: keyof HTMLElementTagNameMap;
  id?: string;
  class?: string;
  className?: string;
  /** Animation type - triggers scroll-based animation */
  animate?: AnimationType;
  /** Use pure CSS animation (no JS) - uses animation-timeline: view() */
  animateCss?: boolean;
  /** Animation plays only once (JS animations only, default: true) */
  animateOnce?: boolean;
  /** CSS animation range preset (CSS animations only) */
  animateRange?: AnimateRange;
  /** Custom animation delay in ms */
  animateDelay?: number;
  /** IntersectionObserver threshold (JS animations only) */
  animateThreshold?: number;
  /** IntersectionObserver root margin (JS animations only) */
  animateRootMargin?: string;
  [key: string]: any;
}

const {
  tag: Element = "section",
  id,
  class: classAttr,
  className,
  animate = "fade-in-up",
  animateCss = false, // Default to JS IntersectionObserver
  animateOnce = false,
  animateRange,
  animateDelay,
  animateThreshold,
  animateRootMargin,
  ...rest
} = Astro.props;

const classes = [classAttr, className].filter(Boolean).join(" ");

// Build animation data attributes
const animationAttrs: Record<string, string | undefined> = {};

if (animate) {
  if (animateCss) {
    // CSS-only animation (uses animation-timeline: view())
    animationAttrs["data-animate-css"] = animate;
    if (animateRange) {
      animationAttrs["data-animate-range"] = animateRange;
    }
  } else {
    // JS-observed animation (uses IntersectionObserver)
    animationAttrs["data-animate"] = animate;
    if (animateOnce) {
      animationAttrs["data-animate-once"] = "true";
    }
    if (animateThreshold !== undefined) {
      animationAttrs["data-animate-threshold"] = String(animateThreshold);
    }
    if (animateRootMargin) {
      animationAttrs["data-animate-root-margin"] = animateRootMargin;
    }
  }
  if (animateDelay !== undefined) {
    animationAttrs["data-animate-delay"] = String(animateDelay);
    animationAttrs["style"] = `--animation-delay: ${animateDelay}ms`;
  }
}
---

<Element id={id} class={classes || undefined} {...animationAttrs} {...rest}>
  <slot />
</Element>
