---
// src/components/ContentRenderer/variants/FilteredPortfolioVariant.astro
/**
 * Filtered Portfolio Variant
 *
 * Industry-filtered portfolio carousel that combines:
 * - 3D carousel transitions between industries
 * - Image cycling within each industry (like screen showcase)
 * - Filter tabs to switch industries
 *
 * Portfolio items are grouped by their `industry` reference field.
 * Clicking filter tabs or arrows triggers 3D carousel animation.
 * Within each industry, images cycle through with slide transitions.
 *
 * @example
 * <ContentRenderer
 *   query={query('projects')}
 *   variant="FilteredPortfolioVariant"
 *   filter={{ showCount: true }}
 * />
 */

import { getImage } from "astro:assets";
import type { BaseVariantProps } from "../ContentRenderer.types";
import type { FilterConfig } from "@/hooks/useFilter";
import SectionHeader from "@/components/SectionHeader.astro";
import Button from "@/components/Button/Button";
import FilteredPortfolioCarousel from "@/components/LoopTemplates/Portfolio/FilteredPortfolioCarousel";
import { shouldShowCollectionCTA } from "../utils/helpers";
import { getImageAlt, resolveImageMetadata } from "@/utils/images";
import { toArray } from "@/utils/array";

interface Props extends BaseVariantProps {
  /** Filter configuration */
  filter?: FilterConfig;
  /** Filter tab size */
  filterSize?: "sm" | "md" | "lg";
  /** Additional class for filter tabs */
  filterClassName?: string;
  /** Show filter tabs */
  showFilters?: boolean;
  /** Show navigation arrows */
  showArrows?: boolean;
  /** Enable drag navigation */
  drag?: boolean;
  /** Custom CTA href */
  ctaHref?: string;
  /** Custom CTA text */
  ctaText?: string;
}

const {
  items = [],
  title,
  heading: headingValue,
  description,
  className = "",
  collectionUrl,
  collectionTitle,
  id,
  showButtonSection = true,
  ctaHref,
  ctaText,
  filter,
  filterSize = "sm",
  filterClassName = "",
  showFilters = true,
  showArrows = true,
  drag = false,
} = Astro.props as Props;

const safeItems = toArray(items) as Record<string, any>[];

// Image optimization settings
const IMAGE_WIDTHS = [480, 640, 860, 1024, 1280, 1600];
const SIZES = "(max-width: 640px) 90vw, (max-width: 1024px) 70vw, 860px";
const IMAGE_FORMATS: { format: "avif" | "webp"; quality: number }[] = [
  { format: "avif", quality: 45 },
  { format: "webp", quality: 65 },
];
const FALLBACK_FORMAT = "webp";

// Process items and generate optimized image data
const processedItems = await Promise.all(
  safeItems.map(async (item) => {
    const primaryImage =
      (typeof item.image === "object" ? item.image : undefined) ??
      item.featuredImage ??
      item.bannerImage;

    const metadata = resolveImageMetadata(primaryImage);
    const altText = primaryImage
      ? getImageAlt(primaryImage, item.title ?? "Project preview")
      : (item.title ?? "Project preview");

    // Preserve industry data for filtering
    const itemData = {
      ...item,
      ...(altText ? { alt: altText } : {}),
    };

    if (!metadata) {
      return {
        data: itemData,
        mediaEntry: undefined,
      };
    }

    // Generate optimized images for each format + width combo
    const optimizedByFormat = await Promise.all(
      IMAGE_FORMATS.map(async ({ format, quality }) => {
        const images = await Promise.all(
          IMAGE_WIDTHS.map((width) =>
            getImage({ src: metadata, width, format, quality })
          )
        );
        return { format, images };
      })
    );

    const fallbackFormatEntry =
      optimizedByFormat.find((e) => e.format === FALLBACK_FORMAT) ??
      optimizedByFormat[optimizedByFormat.length - 1];

    if (!fallbackFormatEntry?.images.length) {
      return {
        data: itemData,
        mediaEntry: undefined,
      };
    }

    const fallbackImages = fallbackFormatEntry.images;
    const fallbackSrcSet = fallbackImages
      .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
      .join(", ");
    const defaultImage = fallbackImages[fallbackImages.length - 1];

    const pictureSources = optimizedByFormat
      .filter((e) => e.format !== FALLBACK_FORMAT)
      .map((entry) => ({
        type: `image/${entry.format}`,
        srcSet: entry.images
          .map((img, i) => `${img.src} ${IMAGE_WIDTHS[i]}w`)
          .join(", "),
        sizes: SIZES,
      }));

    return {
      data: itemData,
      mediaEntry: {
        src: defaultImage.src,
        srcSet: fallbackSrcSet,
        sizes: SIZES,
        width: defaultImage.attributes.width as number,
        height: defaultImage.attributes.height as number,
        alt: altText,
        sources: pictureSources,
      },
    };
  })
);

const portfolioItems = processedItems.map((entry) => entry.data);
const mediaEntries = processedItems.map((entry) => entry.mediaEntry);
const sectionTitle = collectionTitle ?? title;

// SectionHeader handles heading normalization automatically
const showHeader = Boolean(sectionTitle || headingValue || description);
---

<section
  id={id}
  class={`outer-section relative overflow-hidden ${className}`.trim()}
>
  <div class="">
    {showHeader && (
      <SectionHeader
        title={sectionTitle}
        heading={headingValue}
        description={description}
        className="text-center"
        headingClassName="h2 mb-6 heading-padding"
        descriptionClassName="large-text max-w-2xl mx-auto"
      />
    )}

    {portfolioItems.length > 0 && (
      <FilteredPortfolioCarousel
        client:visible
        items={portfolioItems}
        mediaEntries={mediaEntries}
        filter={filter}
        filterSize={filterSize}
        filterClassName={filterClassName}
        showFilters={showFilters}
        showArrows={showArrows}
        drag={drag}
        className={showHeader ? "mt-12" : ""}
      />
    )}

    {showButtonSection &&
      shouldShowCollectionCTA(collectionUrl, portfolioItems.length) &&
      (ctaText || title || collectionTitle) &&
      (ctaHref || collectionUrl) && (
      <div class="buttons-section-center">
        <Button
          client:visible
          href={ctaHref ?? collectionUrl}
          rightIcon="lu:arrow-right"
          variant="secondary"
        >
          {ctaText ?? `View All ${(title ?? collectionTitle ?? "").trim()}`}
        </Button>
      </div>
    )}
  </div>
</section>
